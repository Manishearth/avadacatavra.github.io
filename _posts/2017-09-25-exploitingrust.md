---
layout: post
title: meow
date: 2017-09-25 18:00:00
categories: rust, gdb, exploit
short_description: trying to exploit rust with gdb
image_preview:
---

# Motivation
I've recently been looking into the usage of unsafe code in Rust programs ((unsafe unicorn)[https://github.com/avadacatavra/unsafe-unicorn]). I was curious about what happens when you use a C-style for loop in Rust.

Considering the following two code snippets:
```rust
let x = vec!(1,2,3);
for i in x {
	println!("{}", i);
}
/// outputs:
/// 1
/// 2
/// 3
```

```rust
let x = vec!(1,2,3);
for i in 0..4 {
	println!("{}", x[i]);
}
/// outputs
/// 1
/// 2
/// 3
/// thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 3', ...
```

It turns out that in the implementation of (slice)[https://github.com/rust-lang/rust/blob/master/src/libcore/slice/mod.rs#L742], bounds checking is on by default. The function `slice_index_len_fail` can be called from `index` and `index_mut`. In order to avoid this, there would have to be a custom implementation of `SliceIndex<T>`, and I can't think of a decent reason why this would happen (if you can, let me know).

After a while, I decided that safe Rust would (rightly) prevent 'traditional' overflows, even in non-idiomatic Rust. Therefore, I was going to have to do terrible things and abuse `unsafe`.

# Buffer Overflows

This post assumes some familiarity with buffer overflows and assembly. If you don't know what these are, I recomment:
* (Understanding C by Learning Assembly)[https://www.recurse.com/blog/7-understanding-c-by-learning-assembly]
* (Smashing the Stack for Fun and Profit)[http://www-inst.eecs.berkeley.edu/~cs161/fa08/papers/stack_smashing.pdf]

# Using GDB with Rust

I use a Mac, but I prefer gdb to lldb, so I followed the instructions (here)[https://gist.github.com/hlissner/898b7dfc0a3b63824a70e15cd0180154]. I still had to run with `sudo`, and I'm pretty sure that's because of the way I codesigned gdb.

I used `rust-gdb`, which enables pretty-printing. Rustup installs it by default, so you should be good to go. When running it, point `rust-gdb` at the binary in `target/debug/deps/<crate>-xxx`--if you use the binary in `target/debug/<crate>`, gdb won't be able to load symbols. It will still work, but you won't be able to run commands like `info locals` or `p x`. You also won't be able to step through lines of code, although next instruction does work.

All of the assembly I'll be referencing is in x86 AT&T syntax (instr src dest).

## Setting breakpoints
Set breakpoints just how you normally would:
* `b do_bad_things`
* `b main`
* `rbreak src/main.rs:.`: breaks on all functions in main
	* for some reason, this would only work for me after I manually broke on a function in main.rs 

## Resources
* (Debugging Rust with gdb)[http://thornydev.blogspot.co.uk/2014/01/debugging-rust-with-gdb.html]
* (rust-gdb)[https://michaelwoerister.github.io/2015/03/27/rust-xxdb.html]

# Diving In
```
#[no_mangle]
pub fn chain() {
    let x = 3;
    let y = 4;
    let z = x + y;
    chain1()
}

#[no_mangle]
pub fn chain1() {
    chain2()
}

#[no_mangle]
pub fn chain2() {
    let x = 3;
    let y = 4;
    let z = x + y;
    chain3()
}

#[no_mangle]
pub fn chain3() {
    chain4()
}

#[no_mangle]
pub fn chain4() {
    // put some temp vars on the stack
    let x = 3;
    let y = 4;
    let z = x + y;
    println!("{}", z);
}

pub fn main() {
	chain();
}
```

I wrote a very simple program to look at how Rust allocates memory with the stack. I chained 5 functions together and called the first from main. In gdb, I set breakpoints on each function so I could look at the call stack, then within some functions, I created local variables.

## main
First, gdb breaks at main.

```
 (gdb) info frame
Stack level 0, frame at 0x7fff5fbffa80:
 rip = 0x1000032b2 in for_test::main (src/main.rs:65); saved rip = 0x100030ead
 source language rust.
 Arglist at 0x7fff5fbffa70, args: 
 Locals at 0x7fff5fbffa70, Previous frame's sp is 0x7fff5fbffa80
 Saved registers:
  rbp at 0x7fff5fbffa70, rip at 0x7fff5fbffa78

(gdb) x 0x100030ead
0x100030ead <panic_unwind::__rust_maybe_catch_panic+29>:	0x8348d889
```

The top of the frame is at 0x7fff5fbffa80, the bottom is at 0x7fff5fbffa70 and the return instruction pointer is at 0x7fff5fbffa78. If we look at this address, we see `0x7fff5fbffa78:	0x00030ead	0x00000001`. What's happening here is that the main function returns to `maybe_catch_panic`. You can also see this address in the "saved rip" spot. Another thing to notice is that there's (yet another) rip = 0x1000032b2. This is the address for the main function, so a function called from main will have this set as their saved rip.

The first thing that I noticed is how small the stack for each function is--it's only 2 bytes:

address | |
---|---
0x7fff5fbffa80 | top of frame
0x7fff5fbffa78 | rip
0x7fff5fbffa70 | rbp/arglist/locals.

Let's compare this to a stack setup in C:

```C
void bar(char * p) {
	char buf[100];
	strcpy(buf, p);
}
```

When you call a function in C, the argument is pushed to the stack. Then, when you allocate buf, it's allocated locally (i.e. on the stack, not the heap). This pushes the stack pointer down 100 bytes (stack grows down). This means that the end of the 100 byte buffer immediately precedes the stack pointer, which in turn immediately precedes the return instruction pointer.

| | top of stack
---|---
... | |
100 byte buffer | |
rsp | |
rip | |
p | |

At this point, it should be clear that a Rust stack looks very different than a C stack. The C stack has to fit all of the local variables. Moreover, those local variables are allocated right before the return instruction pointer, so if you can overwrite the buffer, you can set that return pointer to anything you'd like (say, some arbitrary code you wrote earlier in the buffer?).

## Local variables

If Rust doesn't put the local variables on the stack like C, where does it put them?

To answer this, we'll look at the `chain*` functions. For brevity, I'll only be using the last 2 bytes of the addresses (prefix 0x7fff6fb)

function | address | register
---|---|---
main | 0xfa80 | top of frame
| | 0xfa78 | rip
| | 0xfa70 | rbp
chain | 0xf9c0 | top of frame
| | 0xf9b8 | rip
| | 0xf9b0 | rbp
chain1 | 0xf9b0 | top of frame
| | 0xf9a8 | rip
| | 0xf9a0 | rbp
chain2 | 0xf9a0 | top of frame
| | 0xf998 | rip
| | 0xf990 | rbp
chain3 | 0xf990 | top of frame
| | 0xf988 | rip
| | 0xf980 | rbp
chain4 | 0xf980 | top of frame
| | 0xf978 | rip
| | 0xf970 | rbp

The functions chain, chain2, and chain4 each instantiate the same local variables `x, y, z`:

function | var | address
---|---|---
chain | x | 0xf9a4
| | y | 0xf9a8
| | z | 0xf9ac
chain2 | x | 0xf974
| | y | 0xf978
| | z | 0xf97c
chain3 | x | 0xf8e4
| | y | 0xf8e8
| | z | 0xf8ec

# SegFaulting

It's possible! You have to be a very bad person though.




